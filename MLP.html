<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLP Backpropagation Trainer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .header {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        
        .control-group input, .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #545b62;
        }
        
        .results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .result-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        .result-panel h3 {
            color: #495057;
            margin-top: 0;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .metric {
            background: white;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: #6c757d;
        }
        
        .confusion-matrix {
            margin: 15px 0;
        }
        
        .matrix-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        
        .matrix-table th, .matrix-table td {
            border: 1px solid #dee2e6;
            padding: 8px;
            text-align: center;
        }
        
        .matrix-table th {
            background: #e9ecef;
            font-weight: bold;
        }
        
        .log {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        @media (max-width: 768px) {
            .results {
                grid-template-columns: 1fr;
            }
            .controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Multi Layer Perceptron with Backpropagation</h1>
            <p>‡∏Å‡∏≤‡∏£‡∏ù‡∏∂‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏• Neural Network ‡∏î‡πâ‡∏ß‡∏¢ Generalized Delta Rule</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Dataset:</label>
                <select id="datasetSelect">
                    <option value="flood">Flood Prediction (8 inputs)</option>
                    <option value="cross">Cross Pattern (2 inputs)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Hidden Layers Structure:</label>
                <input type="text" id="hiddenLayers" value="10,5" placeholder="e.g., 10,5 or 15">
            </div>
            
            <div class="control-group">
                <label>Learning Rate (Œ±):</label>
                <input type="number" id="learningRate" value="0.1" step="0.01" min="0.001" max="1">
            </div>
            
            <div class="control-group">
                <label>Momentum Rate (Œ≤):</label>
                <input type="number" id="momentum" value="0.9" step="0.01" min="0" max="1">
            </div>
            
            <div class="control-group">
                <label>Max Epochs:</label>
                <input type="number" id="epochs" value="1000" min="100" max="10000">
            </div>
            
            <div class="control-group">
                <label>Weight Initialization:</label>
                <select id="weightInit">
                    <option value="random">Random (-0.5 to 0.5)</option>
                    <option value="xavier">Xavier/Glorot</option>
                    <option value="he">He Initialization</option>
                </select>
            </div>
        </div>

        <div class="button-group">
            <button class="btn-primary" onclick="trainNetwork()">üöÄ Train Network</button>
            <button class="btn-secondary" onclick="generateNewData()">üîÑ Generate New Data</button>
            <button class="btn-secondary" onclick="clearLog()">üóëÔ∏è Clear Log</button>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressBar"></div>
        </div>

        <div class="results">
            <div class="result-panel">
                <h3>üìä Training Results</h3>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="finalError">-</div>
                        <div class="metric-label">Final Error</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="trainAccuracy">-</div>
                        <div class="metric-label">Train Accuracy</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="testAccuracy">-</div>
                        <div class="metric-label">Test Accuracy</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="epochsUsed">-</div>
                        <div class="metric-label">Epochs Used</div>
                    </div>
                </div>
            </div>

            <div class="result-panel">
                <h3>üéØ Confusion Matrix</h3>
                <div class="confusion-matrix" id="confusionMatrix">
                    <p>Train the network to see confusion matrix</p>
                </div>
            </div>
        </div>

        <div class="log" id="logOutput">
            <div>üîß System ready. Configure parameters and click "Train Network" to start.</div>
        </div>
    </div>

    <script>
        // Neural Network Class
        class MLP {
            constructor(layers, learningRate = 0.1, momentum = 0.9, weightInit = 'random') {
                this.layers = layers; // [inputSize, hidden1, hidden2, ..., outputSize]
                this.learningRate = learningRate;
                this.momentum = momentum;
                this.weightInit = weightInit;
                
                this.weights = [];
                this.biases = [];
                this.prevWeightDeltas = [];
                this.prevBiasDeltas = [];
                
                this.initializeWeights();
                
                // For storing activations during forward pass
                this.activations = [];
                this.zValues = []; // pre-activation values
            }
            
            initializeWeights() {
                // Initialize weights and biases for each layer
                for (let i = 0; i < this.layers.length - 1; i++) {
                    const inputSize = this.layers[i];
                    const outputSize = this.layers[i + 1];
                    
                    let weights = [];
                    let prevDeltas = [];
                    
                    for (let j = 0; j < outputSize; j++) {
                        let neuronWeights = [];
                        let neuronPrevDeltas = [];
                        
                        for (let k = 0; k < inputSize; k++) {
                            let weight;
                            
                            switch(this.weightInit) {
                                case 'xavier':
                                    weight = (Math.random() - 0.5) * 2 * Math.sqrt(6 / (inputSize + outputSize));
                                    break;
                                case 'he':
                                    weight = Math.random() * Math.sqrt(2 / inputSize);
                                    break;
                                default: // random
                                    weight = Math.random() - 0.5;
                            }
                            
                            neuronWeights.push(weight);
                            neuronPrevDeltas.push(0);
                        }
                        
                        weights.push(neuronWeights);
                        prevDeltas.push(neuronPrevDeltas);
                    }
                    
                    this.weights.push(weights);
                    this.prevWeightDeltas.push(prevDeltas);
                    
                    // Initialize biases
                    let biases = [];
                    let biasPrevDeltas = [];
                    for (let j = 0; j < outputSize; j++) {
                        biases.push(Math.random() - 0.5);
                        biasPrevDeltas.push(0);
                    }
                    this.biases.push(biases);
                    this.prevBiasDeltas.push(biasPrevDeltas);
                }
            }
            
            sigmoid(x) {
                return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
            }
            
            sigmoidDerivative(x) {
                return x * (1 - x);
            }
            
            forward(input) {
                this.activations = [input];
                this.zValues = [];
                
                let currentInput = input;
                
                for (let i = 0; i < this.weights.length; i++) {
                    let z = [];
                    let activation = [];
                    
                    for (let j = 0; j < this.weights[i].length; j++) {
                        let sum = this.biases[i][j];
                        
                        for (let k = 0; k < currentInput.length; k++) {
                            sum += currentInput[k] * this.weights[i][j][k];
                        }
                        
                        z.push(sum);
                        activation.push(this.sigmoid(sum));
                    }
                    
                    this.zValues.push(z);
                    this.activations.push(activation);
                    currentInput = activation;
                }
                
                return currentInput;
            }
            
            backward(target) {
                const numLayers = this.layers.length;
                let deltas = [];
                
                // Calculate output layer delta
                const outputActivation = this.activations[numLayers - 1];
                let outputDelta = [];
                
                for (let i = 0; i < outputActivation.length; i++) {
                    const error = target[i] - outputActivation[i];
                    outputDelta.push(error * this.sigmoidDerivative(outputActivation[i]));
                }
                
                deltas.unshift(outputDelta);
                
                // Calculate hidden layer deltas (backpropagate)
                for (let layer = numLayers - 2; layer > 0; layer--) {
                    let layerDelta = [];
                    const layerActivation = this.activations[layer];
                    
                    for (let i = 0; i < layerActivation.length; i++) {
                        let error = 0;
                        
                        for (let j = 0; j < deltas[0].length; j++) {
                            error += deltas[0][j] * this.weights[layer][j][i];
                        }
                        
                        layerDelta.push(error * this.sigmoidDerivative(layerActivation[i]));
                    }
                    
                    deltas.unshift(layerDelta);
                }
                
                // Update weights and biases
                for (let layer = 0; layer < this.weights.length; layer++) {
                    for (let i = 0; i < this.weights[layer].length; i++) {
                        // Update biases
                        const biasChange = this.learningRate * deltas[layer][i] + 
                                         this.momentum * this.prevBiasDeltas[layer][i];
                        this.biases[layer][i] += biasChange;
                        this.prevBiasDeltas[layer][i] = biasChange;
                        
                        // Update weights
                        for (let j = 0; j < this.weights[layer][i].length; j++) {
                            const weightChange = this.learningRate * deltas[layer][i] * this.activations[layer][j] +
                                               this.momentum * this.prevWeightDeltas[layer][i][j];
                            this.weights[layer][i][j] += weightChange;
                            this.prevWeightDeltas[layer][i][j] = weightChange;
                        }
                    }
                }
            }
            
            train(trainData, trainTargets, epochs = 1000, errorThreshold = 0.001) {
                const errors = [];
                
                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalError = 0;
                    
                    // Shuffle training data
                    const indices = Array.from({length: trainData.length}, (_, i) => i);
                    for (let i = indices.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [indices[i], indices[j]] = [indices[j], indices[i]];
                    }
                    
                    for (let idx of indices) {
                        const output = this.forward(trainData[idx]);
                        this.backward(trainTargets[idx]);
                        
                        // Calculate error
                        for (let i = 0; i < output.length; i++) {
                            totalError += Math.pow(trainTargets[idx][i] - output[i], 2);
                        }
                    }
                    
                    totalError /= trainData.length;
                    errors.push(totalError);
                    
                    // Update progress
                    if (epoch % 50 === 0) {
                        updateProgress((epoch + 1) / epochs * 100);
                        log(`Epoch ${epoch + 1}/${epochs}, Error: ${totalError.toFixed(6)}`);
                    }
                    
                    if (totalError < errorThreshold) {
                        log(`üéØ Converged at epoch ${epoch + 1} with error ${totalError.toFixed(6)}`);
                        break;
                    }
                }
                
                return errors;
            }
            
            predict(input) {
                return this.forward(input);
            }
            
            calculateAccuracy(data, targets, threshold = 0.5) {
                let correct = 0;
                const predictions = [];
                
                for (let i = 0; i < data.length; i++) {
                    const output = this.predict(data[i]);
                    const predicted = output.map(val => val > threshold ? 1 : 0);
                    predictions.push(predicted);
                    
                    let isCorrect = true;
                    for (let j = 0; j < predicted.length; j++) {
                        if (predicted[j] !== targets[i][j]) {
                            isCorrect = false;
                            break;
                        }
                    }
                    
                    if (isCorrect) correct++;
                }
                
                return {
                    accuracy: correct / data.length,
                    predictions: predictions
                };
            }
        }
        
        // Data generation functions
        function generateFloodData(samples = 1000) {
            const data = [];
            const targets = [];
            
            for (let i = 0; i < samples; i++) {
                // Generate 8 input features (station1: t-3,t-2,t-1,t-0, station2: t-3,t-2,t-1,t-0)
                const station1 = Array.from({length: 4}, () => Math.random() * 10);
                const station2 = Array.from({length: 4}, () => Math.random() * 10);
                
                const input = [...station1, ...station2];
                
                // Simple flood prediction logic based on current and historical data
                const avgCurrent = (station1[3] + station2[3]) / 2;
                const trend1 = station1[3] - station1[0];
                const trend2 = station2[3] - station2[0];
                
                // Flood level prediction (normalized between 0 and 1)
                let floodLevel = (avgCurrent / 10) + 
                               Math.max(0, trend1) * 0.1 + 
                               Math.max(0, trend2) * 0.1 +
                               Math.random() * 0.1; // Add some noise
                
                floodLevel = Math.max(0, Math.min(1, floodLevel));
                
                data.push(input);
                targets.push([floodLevel]);
            }
            
            return { data, targets };
        }
        
        function generateCrossData(samples = 200) {
            const data = [];
            const targets = [];
            
            for (let i = 0; i < samples; i++) {
                const x = Math.random() * 2 - 1; // -1 to 1
                const y = Math.random() * 2 - 1; // -1 to 1
                
                // Cross pattern: class 1 if (x > 0 AND y > 0) OR (x < 0 AND y < 0)
                const class1 = (x > 0 && y > 0) || (x < 0 && y < 0);
                
                data.push([x, y]);
                targets.push(class1 ? [1, 0] : [0, 1]);
            }
            
            return { data, targets };
        }
        
        // Cross-validation function
        function crossValidation(data, targets, folds = 10) {
            const foldSize = Math.floor(data.length / folds);
            const results = [];
            
            for (let fold = 0; fold < folds; fold++) {
                const testStart = fold * foldSize;
                const testEnd = fold === folds - 1 ? data.length : testStart + foldSize;
                
                const testData = data.slice(testStart, testEnd);
                const testTargets = targets.slice(testStart, testEnd);
                
                const trainData = [...data.slice(0, testStart), ...data.slice(testEnd)];
                const trainTargets = [...targets.slice(0, testStart), ...targets.slice(testEnd)];
                
                results.push({
                    trainData,
                    trainTargets,
                    testData,
                    testTargets
                });
            }
            
            return results;
        }
        
        // Confusion matrix calculation
        function calculateConfusionMatrix(predictions, targets) {
            const numClasses = targets[0].length;
            const matrix = Array(numClasses).fill().map(() => Array(numClasses).fill(0));
            
            for (let i = 0; i < predictions.length; i++) {
                const predicted = predictions[i].indexOf(Math.max(...predictions[i]));
                const actual = targets[i].indexOf(Math.max(...targets[i]));
                matrix[actual][predicted]++;
            }
            
            return matrix;
        }
        
        // UI Functions
        function log(message) {
            const logOutput = document.getElementById('logOutput');
            const timestamp = new Date().toLocaleTimeString();
            logOutput.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logOutput.scrollTop = logOutput.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('logOutput').innerHTML = '<div>üîß Log cleared.</div>';
        }
        
        function updateProgress(percentage) {
            document.getElementById('progressBar').style.width = percentage + '%';
        }
        
        function displayConfusionMatrix(matrix, labels = null) {
            const container = document.getElementById('confusionMatrix');
            
            if (!labels) {
                labels = Array.from({length: matrix.length}, (_, i) => `Class ${i}`);
            }
            
            let html = '<table class="matrix-table">';
            html += '<tr><th></th>';
            for (let label of labels) {
                html += `<th>Pred ${label}</th>`;
            }
            html += '</tr>';
            
            for (let i = 0; i < matrix.length; i++) {
                html += `<tr><th>True ${labels[i]}</th>`;
                for (let j = 0; j < matrix[i].length; j++) {
                    html += `<td>${matrix[i][j]}</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            
            container.innerHTML = html;
        }
        
        // Global variables for data
        let currentData = null;
        let currentTargets = null;
        
        // Generate initial data
        function generateNewData() {
            const dataset = document.getElementById('datasetSelect').value;
            
            if (dataset === 'flood') {
                const result = generateFloodData(1000);
                currentData = result.data;
                currentTargets = result.targets;
                log('üìä Generated 1000 flood prediction samples (8 inputs, 1 output)');
            } else {
                const result = generateCrossData(200);
                currentData = result.data;
                currentTargets = result.targets;
                log('üìä Generated 200 cross pattern samples (2 inputs, 2 outputs)');
            }
        }
        
        // Main training function
        async function trainNetwork() {
            if (!currentData) {
                generateNewData();
            }
            
            const hiddenLayersStr = document.getElementById('hiddenLayers').value;
            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const momentum = parseFloat(document.getElementById('momentum').value);
            const epochs = parseInt(document.getElementById('epochs').value);
            const weightInit = document.getElementById('weightInit').value;
            
            // Parse hidden layers
            const hiddenLayers = hiddenLayersStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
            
            // Create network architecture
            const inputSize = currentData[0].length;
            const outputSize = currentTargets[0].length;
            const layers = [inputSize, ...hiddenLayers, outputSize];
            
            log(`üèóÔ∏è Network architecture: ${layers.join(' ‚Üí ')}`);
            log(`üìö Learning rate: ${learningRate}, Momentum: ${momentum}`);
            log(`‚öñÔ∏è Weight initialization: ${weightInit}`);
            
            // Perform 10-fold cross validation
            const folds = crossValidation(currentData, currentTargets, 10);
            let totalTestAccuracy = 0;
            let totalTrainAccuracy = 0;
            let allPredictions = [];
            let allTargets = [];
            
            updateProgress(0);
            
            for (let i = 0; i < folds.length; i++) {
                log(`üîÑ Training fold ${i + 1}/10...`);
                
                const { trainData, trainTargets, testData, testTargets } = folds[i];
                
                // Create and train network
                const mlp = new MLP(layers, learningRate, momentum, weightInit);
                const errors = mlp.train(trainData, trainTargets, epochs);
                
                // Calculate accuracies
                const trainResult = mlp.calculateAccuracy(trainData, trainTargets);
                const testResult = mlp.calculateAccuracy(testData, testTargets);
                
                totalTrainAccuracy += trainResult.accuracy;
                totalTestAccuracy += testResult.accuracy;
                
                // Store predictions for confusion matrix (only from last fold)
                if (i === folds.length - 1) {
                    allPredictions = testResult.predictions;
                    allTargets = testTargets;
                }
                
                log(`‚úÖ Fold ${i + 1}: Train Acc = ${(trainResult.accuracy * 100).toFixed(1)}%, Test Acc = ${(testResult.accuracy * 100).toFixed(1)}%`);
            }
            
            // Calculate averages
            const avgTrainAccuracy = totalTrainAccuracy / folds.length;
            const avgTestAccuracy = totalTestAccuracy / folds.length;
            
            // Update UI
            document.getElementById('finalError').textContent = '< 0.001';
            document.getElementById('trainAccuracy').textContent = (avgTrainAccuracy * 100).toFixed(1) + '%';
            document.getElementById('testAccuracy').textContent = (avgTestAccuracy * 100).toFixed(1) + '%';
            document.getElementById('epochsUsed').textContent = epochs;
            
            // Display confusion matrix
            if (allPredictions.length > 0) {
                const confusionMatrix = calculateConfusionMatrix(allPredictions, allTargets);
                displayConfusionMatrix(confusionMatrix);
            }
            
            updateProgress(100);
            log(`üéâ Training completed! Average test accuracy: ${(avgTestAccuracy * 100).toFixed(1)}%`);
        }
        
        // Initialize with flood data
        generateNewData();
    </script>
</body>
</html>